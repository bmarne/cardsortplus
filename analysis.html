<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Card Sorting Analysis</title>
    <style>
      /* Reset */
      body, html {
        margin: 0;
        padding: 0;
        font-family: sans-serif;
        color: #000;
      }
      body {
        padding-bottom: 60vh;
      }
      * {
        box-sizing: border-box;
      }
      .results-input-container {
        padding: 15px;
      }
      .results-input-container .title-bar {
        padding: 0 0 15px 0;
      }
      .results-input-container .title-bar h2 {
        margin: 0;
      }
      #results-input {
        padding: 0.5em;
        width: 100%;
        height: 2.5em;
      }
      /* Category refinement */
      .category-refinement {
        position: relative;
      }
      .category-refinement .title-bar {
        position: sticky;
        display: flex;
        align-items: center;
        top: 0;
        gap: 15px;
        padding: 15px;
        background: #fff;
      }
      .category-refinement .title-bar h2 {
        margin: 0;
      }
      .dendrogram .title-bar {
        position: sticky;
        top: 0;
        padding: 15px;
        background: #fff;
      }
      .category-refinement .title-bar button,
      .category-refinement .title-bar input[type="checkbox"],
      .category-refinement .title-bar label,
      .associations .title-bar button,
      button.associations-button-swap-axes {
        cursor: pointer;
      }
      .category-refinement .title-bar button[disabled] {
        cursor: not-allowed;
      }
      .category-refinement .categories {
        padding: 15px;
      }
      .category-refinement .category {
        display: grid;
        grid-template-columns: 205px 1fr;
        grid-template-rows: min-content 1fr;
        grid-template-areas:
          "topleft right"
          "left right"
          "bottomleft right";
        gap: 7px 7px;
        margin-bottom: 10px;
        width: 100%;
        padding: 10px;
        background: #fff;
        box-shadow: 0 2px 10px rgba(0, 0, 0, .1);
      }
      .category-refinement .category-name {
        grid-area: topleft;
        white-space: pre-wrap;
        outline-offset: 3px;
      }
      .category-refinement .category-name:hover:not(:focus):not(:active) {
        outline: 2px solid #ddd;
      }
      .category-refinement .category-merge-tool {
        grid-area: bottomleft;
      }
      .category-refinement .merged-categories {
        grid-area: left;
      }
      .category-refinement .category-merge-tool button {
        --border-lighter: rgba(0,0,0,.15);
        --border-darker: rgba(0,0,0,.3);
        background: #fff;
        border-width: 2px;
        border-radius: 5px;
        border-color: var(--border-lighter) var(--border-darker) var(--border-darker) var(--border-lighter);
        padding: 3px 7px;
        cursor: pointer;
      }
      .category-refinement .category-merge-tool button:active {
        border-color: var(--border-darker) var(--border-lighter) var(--border-lighter) var(--border-darker);
      }
      .category-refinement .category-merge-button-start {
        opacity: 0;
      }
      .category-refinement .category:hover .category-merge-button-start,
      .category-refinement .category-merge-button-start:focus {
        opacity: 1;
      }
      .category-refinement .categories:not(.is-merge-active) .category-merge-button-end,
      .category-refinement .categories.is-merge-active .is-merge-source .category-merge-button-end,
      .category-refinement .categories.is-merge-active .category-merge-button-start,
      .category-merge-button-cancel {
        display: none;
      }
      .category-refinement .has-merged-categories .category-merge-button-start {
        visibility: hidden;
      }
      .is-merge-active .is-merge-source .category-merge-button-cancel {
        display: unset;
      }
      .category-refinement .category.is-merge-pending .category-merge-tool {
        display: none;
      }
      .category-refinement .category.is-merge-pending {
        opacity: .3;
      }
      .category-refinement .category.is-merge-pending .category-name,
      .category-refinement .merged-category.is-undo-pending .merged-category-name {
        text-decoration: line-through;
      }
      .category-refinement .merged-category {
        display: flex;
        align-items: baseline;
        font-size: 80%;
      }
      .category-refinement .merged-category-name {
        flex-grow: 1;
        margin-left: 0.3em;
      }
      .category-refinement .merged-category-button-undo {
        cursor: pointer;
        filter: grayscale(1);
      }
      .category-refinement .category-cards {
        grid-area: right;
        display: flex;
        flex-wrap: wrap;
        align-items: flex-start;
        align-content: flex-start;
        margin-bottom: -10px;
      }
      .category-refinement .card {
        display: flex;
        padding: 5px;
        margin-bottom: 10px;
        --weight: 0;
        --more-weight: calc(var(--weight) + 0.3);
        background-color: rgba(102, 102, 255, var(--weight));
        border: 1px solid rgba(102, 102, 255, 0);
        border-color: rgba(102, 102, 255, var(--more-weight));
        border-radius: 5px;
        box-shadow: 0 0 0 2px rgba(0, 0, 0, 0);
        --similarity-highlight: 0 0 0 2px rgba(0, 0, 0, 1);
        transition: box-shadow .1s ease-in;
      }
      .category-refinement .card:not(:last-child) {
        margin-right: 10px;
      }
      .category-refinement .card-text {
        margin-right: 0.25em;
        max-width: calc(100vw - 300px);
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      .category-refinement .card-text .oldtext {
        text-decoration-line: line-through;
        font-size: 80%;
        color: darkblue;
      }
      /* Association table */
      .associations {
        position: relative;
        padding: 15px;
      }
      .associations .title-bar {
        position: sticky;
        top: 0;
        padding: 15px 0;
        width: fit-content;
        background: #fff;
      }
      .associations .title-bar h2 {
        margin: 0;
      }
      .association-table {
        border-collapse: collapse;
        --border-styles: 1px solid #eee;
      }
      .association-table tr:first-of-type th:first-of-type {
        text-align: right;
        vertical-align: bottom;
        padding: 15px;
      }
      .association-table .associations-button-swap-axes {
        margin: 15px 0 0 15px;
      }
      .association-table th {
        text-align: inherit;
        font-weight: inherit;
        padding: 0;
      }
      .association-table td {
        border: var(--border-styles);
        padding: 0;
      }
      .association-table .x-axis-head-cell {
        width: 30px;
        height: 200px;
        vertical-align: bottom;
      }
      .association-table .x-axis-head-text {
        position: absolute;
        width: 260px;
        transform-origin: left bottom;
        transform: translateX(16px) translateY(-20px) rotate(-45deg);
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
      }
      .association-table .y-axis-head-text {
        padding-right: 0.25em;
        text-align: right;
        white-space: nowrap;
        border-bottom: var(--border-styles);
      }
      .association-table .x-axis-head-text .oldtext,
      .association-table .y-axis-head-text .oldtext {
        text-decoration-line: line-through;
        font-size: 70%;
        color: darkgrey;
      }
      .association-table .card-correlation {
        display: flex;
        align-items: center;
        justify-content: center;
        --light: #fff;
        --dark: #333;
        --weight: 0;
        background-color: rgba(102, 102, 255, var(--weight));
        width: 28px;
        height: 28px;
        overflow: hidden;
      }

      .link { stroke:#6666ff; fill:none; stroke-width:1.5; }
      .legend { margin-left:8px; display:flex; gap:8px; align-items:center; flex-wrap:wrap; }
      .legend .item { display:flex; gap:6px; align-items:center;}
      .colorbox { width:1em; height:1em; border:1px solid #999; display:inline-block; }
      .controls-row { display:flex; gap:8px; align-items:center; }
      #kValue { font-weight:600; margin-left:0.5em; }
      input[type="range"] { vertical-align:middle; }
      .editable-input { padding:2px 4px; }
      button#redraw {display:none;}
      .legend-title * {display: inline}
      input#labelNum {width: 3em}
    </style>
  </head>
  <body>
    <div id="results-input-container" class="results-input-container">
      <div class="title-bar">
        <h2>Data input</h2>
      </div>
      <div>
        <label for="results-input">Paste one or more results below to add them</label>
      </div>
      <textarea id="results-input"></textarea>
    </div>
    <div id="category-refinement" class="category-refinement">
      <style class="similarity-hover-effect-stylesheet"></style>
      <div class="title-bar">
        <h2>Category refinement</h2>
        <button>ü§ñ Auto-merge</button>
        <button class="button-recalculate" disabled>üëá Apply changes</button>
        <label for="similarity-hover-effect-toggle">
          <input type="checkbox" id="similarity-hover-effect-toggle" />
          Similarity highlight on hover
        </label>
      </div>
      <div class="categories"></div>
    </div>
    <div id="associations" class="associations">
      <div class="title-bar">
        <h2>Category&ndash;card table</h2>
        <button class="btn-share-result">üîó Share result</button>
        <button class="btn-export-result">üì¶ Export result</button>
      </div>
      <table class="association-table"></table>
    </div>
    <div id="dendrogram" class="dendrogram">
      <div class="title-bar">
        <h2>Card dendrogram (alpha version, for testing purpose only)</h2>
        <div class="dd-controls">
          <div class="dd-controls-row">
            <label>üóÇÔ∏è Grouping algorithm:
              <select id="linkageSelect">
                <option value="single">Single (min)</option>
                <option value="complete">Complete (max)</option>
                <option value="average">Average (UPGMA)</option>
              </select>
            </label>
            <label>üìè Distance algorithm:
              <select id="distSelect">
                <option value="jaccardDistance">Jaccard</option>
                <option value="brayCurtisDistance">Bray-Curtis</option>
                <option value="manhattanDistance">Manhattan</option>
                <option value="euclideanDistance">Euclidean</option>
                <option value="cosineDistance">Cosine</option>
              </select>
            </label>
            <button id="redraw">üñåÔ∏è Draw</button><button id="exportSvg">üì¶ Export SVG</button>
          </div>
          <div class="dd-controls-row">
            <label for="kRange">Number of Categories (k):</label>
            <input id="kRange" type="range" min="1" max="15" value="3" step="1" />
            <span id="kValue">3</span>
            <div class="legend-title">
              <h3>Categories</h3>
              (<label for="labelNum">Number of categories used for labels below: </label>
              <input id="labelNum" type="number" name="number" value="2"/>)
            </div>
            <div class="legend" id="legend"></div>
          </div>
        </div>
      </div>
      <div id="dd-container"></div>
    </div>
    <template class="category-template">
      <div class="category" spellcheck="false">
        <div class="category-name"></div>
        <div class="category-cards"></div>
        <div class="merged-categories"></div>
        <div class="category-merge-tool">
          <button class="category-merge-button-start">ü´¥ Merge this category into...</button>
          <button class="category-merge-button-end">üëâ Merge into here</button>
          <button class="category-merge-button-cancel">‚ùå Cancel merge</button>
        </div>
      </div>
    </template>
    <template class="merged-category-template">
      <div class="merged-category">
        <div class="merged-category-button-undo">‚ùå</div>
        <div class="merged-category-name"></div>
      </div>
    </template>
    <template class="card-template">
      <div class="card">
        <div class="card-text"></div>
        <div class="card-correlation"></div>
      </div>
    </template>
    <script src="pako-2.0.4.min.js"></script>
    <script src="common-scripts.js"></script>
    <script>
      const resultsInput = document.querySelector('#results-input');
      let mergedCategories = {};
      var renamedCategories = {};
      let loadedResults = [];
      resultsInput.addEventListener('input', handleResultsInput);
      const jsonSplitRegex = /\}[^{}]*\{/;
      const editedCardRegex = /^--- (.*?) \+\+\+ (.*?)$/;
      const buttonExportResult = document.querySelector('.btn-export-result');
      buttonExportResult.addEventListener('click', exportResult);
      const buttonShareResult = document.querySelector('.btn-share-result');
      buttonShareResult.addEventListener('click', shareResult);
      var csv = "";
      async function handleResultsInput() {
        const text = resultsInput.value;
        let results = [];
        if (text.includes('{')) {
          try {
            results = [JSON.parse(text)];
          }
          catch(e) {
            results = text.split(jsonSplitRegex);
            results[0] = results[0] + '}';
            for (let i = 1; i < results.length - 1; i++) {
              results[i] = '{' + results[i] + '}';
            }
            results[results.length - 1] = '{' + results[results.length - 1];
            results = results.map(JSON.parse);
          }
        }
        else if (text.includes('http')) {
          results = text.split('http');
          results = results.map(result => result.trim());
          results = results.filter(result => !!result);
          results = results.map(async result => {
            const url = 'http' + result;
            const urlObj = new URL(url);
            const data = await loadFromString(urlObj.hash.split('#').pop());
            const keyValuePairs = Object.entries(data).filter(([key, value]) => !reservedKeys.includes(key));
            result = Object.fromEntries(keyValuePairs);
            return result;
          });
          results = await Promise.all(results);
        }
        if (results.length > 0) {
          resultsInput.value = '';
          addToLoadedResults(results);
        }
      }

      function addToLoadedResults(newResults) {
        const concatenatedResults = loadedResults.concat(newResults);
        const seenResultStrings = new Set();
        const uniqueResults = [];
        for (const result of concatenatedResults) {
          const resultAsStr = JSON.stringify(result);
          if (seenResultStrings.has(resultAsStr)) {
            continue;
          }
          seenResultStrings.add(resultAsStr);
          uniqueResults.push(result);
        }
        loadedResults = uniqueResults;
        calculateAndRender();
      }

      function calculateAndRender() {
        const data = combineResults(loadedResults);

        calculateCategorySimilarities(data);
        calculateCardSimilarities(data);

        sortCategoriesBySimilarity(data);
        sortCardsBySimilarity(data);

        renderCategoryRefinement(data);
        renderAssociationTable(data);

        renderDendrogram(csv);

        console.log('data', data);
      }

      function combineResults(results) {
        const data = {
          categories: [],
          cards: [],
          cardCountsByCategory: {},
          resultCount: results.length,
        };
        for (const result of results) {
          for (let [categoryName, cards] of Object.entries(result)) {
            if (categoryName in mergedCategories) {
              categoryName = mergedCategories[categoryName];
            }
            if ( ! (categoryName in data.cardCountsByCategory)) {
              data.cardCountsByCategory[categoryName] = {};
              data.categories.push({
                name: categoryName,
                categorySimilarities: {},
              });
            }
            const cardCountCategory = data.cardCountsByCategory[categoryName];
            for (const card of cards) {
              if ( ! (card in cardCountCategory)) {
                cardCountCategory[card] = 0;
              }
              cardCountCategory[card] += 1;
              let cardObj = data.cards.find(cardObj => cardObj.text == card);
              if (cardObj === undefined) {
                cardObj = {
                  text: card,
                  categories: [],
                  cardSimilarities: {},
                };
                data.cards.push(cardObj);
              }
              cardObj.categories.push(categoryName);
            }
          }
        }
        return data;
      }

      function calculateCategorySimilarities(data) {
        for (const categoryA of data.categories) {
          const cardsA = Object.keys(data.cardCountsByCategory[categoryA.name]);
          for (const categoryB of data.categories) {
            if (categoryB.name in categoryA.categorySimilarities) {
              continue;
            }
            const cardsB = Object.keys(data.cardCountsByCategory[categoryB.name]);
            let amountOfCardsInBoth = 0;
            let amountOfCardsInA = cardsA.length;
            let amountOfCardsInB = cardsB.length;
            for (const cardA of cardsA) {
              if (cardsB.includes(cardA)) {
                amountOfCardsInBoth += 1;
                amountOfCardsInA -= 1;
                amountOfCardsInB -= 1;
              }
            }
            const jaccardScore = amountOfCardsInBoth / (amountOfCardsInBoth + amountOfCardsInA + amountOfCardsInB);
            categoryA.categorySimilarities[categoryB.name] = jaccardScore;
          }
        }
      }

      function calculateCardSimilarities(data) {
        for (const cardA of data.cards) {
          for (const cardB of data.cards) {
            if (cardB.text in cardA.cardSimilarities) {
              continue;
            }
            let amountOfCategoriesContainingBoth = 0;
            let amountOfCategoriesContainingA = cardA.categories.length;
            let amountOfCategoriesContainingB = cardB.categories.length;
            for (const categoryA of cardA.categories) {
              if (cardB.categories.includes(categoryA)) {
                amountOfCategoriesContainingBoth += 1;
                amountOfCategoriesContainingA -= 1;
                amountOfCategoriesContainingB -= 1;
              }
            }
            const jaccardScore = amountOfCategoriesContainingBoth / (amountOfCategoriesContainingBoth + amountOfCategoriesContainingA + amountOfCategoriesContainingB);
            cardA.cardSimilarities[cardB.text] = jaccardScore;
          }
        }
      }

      function sortCategoriesBySimilarity(data) {
        const sortedCategories = [];
        const unsortedCategories = Array.from(data.categories);
        while (unsortedCategories.length > 0) {
          const category = unsortedCategories.shift();
          sortedCategories.push(category);
          const similarities = Object.entries(category.categorySimilarities).map(([name, similarity]) => ({name, similarity}));
          similarities.sort((a, b) => b.similarity - a.similarity);
          for (const categorySimilarity of similarities) {
            if (categorySimilarity.similarity <= 0.3) {
              break;
            }
            const categoryIndex = unsortedCategories.findIndex(category => category.name == categorySimilarity.name);
            if (categoryIndex !== -1) {
              sortedCategories.push(unsortedCategories.splice(categoryIndex, 1)[0]);
            }
          }
        }
        data.categories = sortedCategories;
      }

      function sortCardsBySimilarity(data) {
        const sortedCards = [];
        const unsortedCards = Array.from(data.cards);
        while (unsortedCards.length > 0) {
          const card = unsortedCards.shift();
          sortedCards.push(card);
          const similarities = Object.entries(card.cardSimilarities).map(([text, similarity]) => ({text, similarity}));
          similarities.sort((a, b) => b.similarity - a.similarity);
          for (const cardSimilarity of similarities) {
            if (cardSimilarity.similarity <= 0.3) {
              break;
            }
            const cardIndex = unsortedCards.findIndex(card => card.text == cardSimilarity.text);
            if (cardIndex !== -1) {
              sortedCards.push(unsortedCards.splice(cardIndex, 1)[0]);
            }
          }
        }
        data.cards = sortedCards;
      }

      // Category refinement
      const categoriesContainer = document.querySelector('.category-refinement .categories');
      const categoryTemplate = document.querySelector('.category-template');
      const cardTemplate = document.querySelector('.card-template');
      const recalculateButton = document.querySelector('.category-refinement .button-recalculate');

      recalculateButton.addEventListener('click', () => calculateAndRender());

      const similarityHoverEffectStyleElement = document.querySelector('.similarity-hover-effect-stylesheet');
      const similarityHoverEffectToggleInput = document.querySelector('#similarity-hover-effect-toggle');
      let isSimilarityHoverEffectEnabled = similarityHoverEffectToggleInput.checked;
      similarityHoverEffectToggleInput.addEventListener('change', () => isSimilarityHoverEffectEnabled = similarityHoverEffectToggleInput.checked);
      let isSimilarityHoverEffectApplied = false;
      document.body.addEventListener('mouseover', function handleMouseOver() {
        if ( ! isSimilarityHoverEffectApplied) {
          return;
        }
        similarityHoverEffectStyleElement.innerHTML = '';
        isSimilarityHoverEffectApplied = false;
      });
      initialize();

      function renderCategoryRefinement(data) {
        const categoryElements = [];
        for (const category of data.categories) {
          const categoryElement = document.importNode(categoryTemplate.content.children[0], true);
          const similarityHoverSelector = [];
          const cardElements = [];
          const cardEntries = Object.entries(data.cardCountsByCategory[category.name]);
          cardEntries.sort(([textA], [textB]) => textA.localeCompare(textB));
          for (const [cardText, cardCount] of cardEntries) {
            const cardElement = document.importNode(cardTemplate.content.children[0], true);
            const cardPercentage = Math.round((cardCount / data.resultCount) * 100.0);
            const weight = (cardPercentage / 100.0) / 2.0;
            cardElement.style.setProperty('--weight', weight);
            cardElement.querySelector('.card-text').innerHTML = cardText.replace(editedCardRegex,"<div class='oldtext'>$1</div><div class='newtext'>$2</div>");
            cardElement.querySelector('.card-correlation').textContent = `${cardPercentage}%`;
            cardElement.querySelector('.card-correlation').title = `${cardCount}/${data.resultCount} participants`;
            cardElements.push(cardElement);
            // Similarity hover effect
            const textBase64 = btoa(unescape(encodeURIComponent(cardText)));
            cardElement.setAttribute('data-text-b64', textBase64);
            similarityHoverSelector.push(`.category-refinement .card[data-text-b64="${textBase64}"]`);
            cardElement.addEventListener('mouseover', function handleMouseOver(event) {
              if ( ! isSimilarityHoverEffectEnabled) {
                return;
              }
              event.stopPropagation();
              isSimilarityHoverEffectApplied = true;
              similarityHoverEffectStyleElement.innerHTML = `.category-refinement .card[data-text-b64="${textBase64}"] { box-shadow: var(--similarity-highlight); }`;
            });
          }
          category.element = categoryElement;
          categoryElement._category = category;
          const categoryNameElement = categoryElement.querySelector('.category-name');
          categoryNameElement.textContent = renamedCategories[category.name] || category.name;
          categoryNameElement.addEventListener('input', () => {
            renamedCategories[category.name] = categoryNameElement.textContent;
            categoryNameElement.classList.add('dirty');
            updateRecalculateButton();
          });
          setContentEditablePlaintext(categoryNameElement);
          categoryElement.querySelector('.category-cards').replaceChildren(...cardElements);
          categoryElement.querySelector('.category-merge-button-start').addEventListener('click', handleMergeStart);
          categoryElement.querySelector('.category-merge-button-end').addEventListener('click', handleMergeEnd);
          categoryElement.querySelector('.category-merge-button-cancel').addEventListener('click', handleMergeCancel);
          categoryElements.push(categoryElement);
          const thisCategoryMergedCategories = (
            Object.entries(mergedCategories)
            .filter(([sourceName, targetName]) => targetName == category.name)
            .map(([sourceName, targetName]) => sourceName)
          );
          if (thisCategoryMergedCategories.length > 0) {
            categoryElement.classList.add('has-merged-categories');
            for (sourceCategoryName of thisCategoryMergedCategories) {
              renderMergeToolMergedCategory(categoryElement, {name: sourceCategoryName});
            }
          }
          // Similarity hover effect
          const similarityStyleText = `${similarityHoverSelector.join(', ')} { box-shadow: var(--similarity-highlight); }`;
          categoryElement.addEventListener('mouseover', function handleMouseOver() {
            if ( ! isSimilarityHoverEffectEnabled) {
              return;
            }
            event.stopPropagation();
            isSimilarityHoverEffectApplied = true;
            similarityHoverEffectStyleElement.innerHTML = similarityStyleText;
          });
        }
        categoriesContainer.replaceChildren(...categoryElements);
        updateRecalculateButton();
      }

      function handleMergeStart() {
        const categoryElement = this.closest('.category');
        categoriesContainer.classList.add('is-merge-active');
        categoryElement.classList.add('is-merge-source');
      }
      function handleMergeCancel() {
        const categoryElement = this.closest('.category');
        categoriesContainer.classList.remove('is-merge-active');
        categoryElement.classList.remove('is-merge-source');
      }
      function handleMergeEnd() {
        const targetCategoryElement = this.closest('.category');
        const sourceCategoryElement = categoriesContainer.querySelector('.is-merge-source');
        const targetCategory = targetCategoryElement._category;
        const sourceCategory = sourceCategoryElement._category;
        categoriesContainer.classList.remove('is-merge-active');
        sourceCategoryElement.classList.remove('is-merge-source');
        sourceCategoryElement.classList.add('is-merge-pending');
        targetCategoryElement.classList.add('has-merged-categories');
        renderMergeToolMergedCategory(targetCategoryElement, sourceCategory);
        mergedCategories[sourceCategory.name] = targetCategory.name;
        updateRecalculateButton();
      }
      function handleMergeUndo() {
        const undoButton = this;
        const targetCategoryElement = undoButton.closest('.category');
        const targetCategory = targetCategoryElement._category;
        const sourceCategory = undoButton._sourceCategory;
        const sourceCategoryElement = sourceCategory.element;
        if (sourceCategoryElement) {
          if (sourceCategoryElement.classList.contains('is-merge-pending')) {
            sourceCategoryElement.classList.remove('is-merge-pending');
          }
          undoButton.closest('.merged-category').remove();
        }
        else {
          undoButton.closest('.merged-category').classList.add('is-undo-pending');
        }
        delete mergedCategories[sourceCategory.name];
        const hasMoreMergedCategories = Object.values(mergedCategories).includes(targetCategory.name);
        if ( ! hasMoreMergedCategories) {
          targetCategoryElement.classList.remove('has-merged-categories');
        }
        updateRecalculateButton();
      }
      function updateRecalculateButton() {
        if (categoriesContainer.querySelector('.is-merge-pending, .is-undo-pending, .dirty')) {
          recalculateButton.disabled = false;
        }
        else {
          recalculateButton.disabled = true;
        }
      }

      function renderMergeToolMergedCategory(targetCategoryElement, sourceCategory) {
        const mergedContainer = targetCategoryElement.querySelector('.merged-categories');
        const mergedCategoryElement = document.importNode(document.querySelector('.merged-category-template').content.children[0], true);
        mergedCategoryElement.querySelector('.merged-category-name').textContent = sourceCategory.name;
        const undoButton = mergedCategoryElement.querySelector('.merged-category-button-undo');
        undoButton._sourceCategory = sourceCategory;
        undoButton.addEventListener('click', handleMergeUndo);
        mergedContainer.appendChild(mergedCategoryElement);
      }

      // Card-category association table
      const associationTable = document.querySelector('.association-table');

      associationTable.addEventListener('click', function handleClick(event) {
        if (event.target.matches('.associations-button-swap-axes')) {
          associationTableSwapAxes(event.target);
        }
      });

      function renderAssociationTable(data) {
        let tableHtml = '';
        let tableCSV1 = '';
        let tableCSV2 = '';
        // Categories on X-axis, Cards on Y-axis
        tableHtml += '<tbody class="x-categories-y-cards">';
        tableHtml += '<tr>';
        tableHtml += `
        <th>
          Categories ‚Üí
          <br />
          Cards ‚Üì
          <button class="associations-button-swap-axes" data-target="x-cards-y-categories">üîÉ Swap axes</button>
        </th>
        `;
        tableCSV1 += `Cards,`;
        for (const category of data.categories) {
          tableHtml += `
          <th class="x-axis-head-cell">
            <div class="x-axis-head-text">${asTextContent(renamedCategories[category.name] || category.name)}</div>
          </th>
          `;
          tableCSV1 += `${asTextContent(renamedCategories[category.name] || category.name)},`;
        }
        tableHtml += '</tr>';
        tableCSV1 = tableCSV1.slice(0,-1) + '\n';
        for (const card of data.cards) {
          tableHtml += `<tr>`;
          const thText = asTextContent(card.text).replace(editedCardRegex,"<div class='oldtext'>$1</div><div class='newtext'>$2</div>");
          tableHtml += `<th class="y-axis-head-text">${thText}</th>`;
          tableCSV1 += `${asTextContent(card.text)},`;
          for (const category of data.categories) {
            const cardCount = data.cardCountsByCategory[category.name][card.text];
            const cardPercentage = cardCount ? Math.round((cardCount / data.resultCount) * 100.0) : 0;
            const weight = cardPercentage / 100.0;
            const fontColor = weight > 0.5 ? '--light' : '--dark';
            if (cardCount > 0) {
              tableHtml += `
              <td>
                <div
                  class="card-correlation"
                  style="--weight: ${weight}; color: var(${fontColor});"
                  title="${cardCount}/${data.resultCount} participants\n\nCard: ${asTextContent(card.text)}\n\nCategory: ${asTextContent(renamedCategories[category.name] || category.name)}"
                >${cardPercentage}</div>
              </td>
              `;
              tableCSV1 += `${cardCount},`;
            }
            else {
              tableHtml += `<td><div class="card-correlation"></div></td>`;
              tableCSV1 += '0,';
            }
          }
          tableHtml += '</tr>';
          tableCSV1 = tableCSV1.slice(0,-1) + '\n';
        }
        tableHtml += '</tbody>';
        // Cards on X-axis, Categories on Y-axis
        tableHtml += '<tbody class="x-cards-y-categories" style="display: none;">';
        tableHtml += '<tr>';
        tableHtml += `
        <th>
          Cards ‚Üí
          <br />
          Categories ‚Üì
          <button class="associations-button-swap-axes" data-target="x-categories-y-cards">üîÑ Swap axes</button>
        </th>
        `;
        tableCSV2 += `Categories,`;
        for (const card of data.cards) {
          const thText = asTextContent(card.text).replace(editedCardRegex,"<div class='oldtext'>$1</div><div class='newtext'>$2</div>");
          tableHtml += `
          <th class="x-axis-head-cell">
            <div class="x-axis-head-text">${thText}</div>
          </th>
          `;
          tableCSV2 += `${asTextContent(card.text)},`;
        }
        tableHtml += '</tr>';
        tableCSV2 = tableCSV2.slice(0,-1) + '\n';
        for (const category of data.categories) {
          tableHtml += `<tr>`;
          tableHtml += `<th class="y-axis-head-text">${asTextContent(renamedCategories[category.name] || category.name)}</th>`;
          tableCSV2 += `${asTextContent(renamedCategories[category.name] || category.name)},`;
          for (const card of data.cards) {
            const cardCount = data.cardCountsByCategory[category.name][card.text];
            const cardPercentage = cardCount ? Math.round((cardCount / data.resultCount) * 100.0) : 0;
            const weight = cardPercentage / 100.0;
            const fontColor = weight > 0.5 ? '--light' : '--dark';
            if (cardCount > 0) {
              tableHtml += `
              <td>
                <div
                  class="card-correlation"
                  style="--weight: ${weight}; color: var(${fontColor});"
                  title="${cardCount}/${data.resultCount} participants\n\nCard: ${asTextContent(card.text)}\n\nCategory: ${asTextContent(renamedCategories[category.name] || category.name)}"
                >${cardPercentage}</div>
              </td>
              `;
              tableCSV2 += `${cardCount},`;
            }
            else {
              tableHtml += `<td><div class="card-correlation"></div></td>`;
              tableCSV2 += '0,';
            }
          }
          tableHtml += '</tr>';
          tableCSV2 = tableCSV2.slice(0,-1) + '\n';
        }
        tableHtml += '</tbody>';
        associationTable.innerHTML = tableHtml;
        associationTable.setAttribute("data-content-yCSV",tableCSV1);
        associationTable.setAttribute("data-content-xCSV",tableCSV2);
        csv = tableCSV1;
      }

      function associationTableSwapAxes(button) {
        const target = button.getAttribute('data-target');
        if (target == 'x-categories-y-cards') {
          document.querySelector('.association-table .x-cards-y-categories').style.display = 'none';
          document.querySelector('.association-table .x-categories-y-cards').style.display = '';
        }
        else {
          document.querySelector('.association-table .x-categories-y-cards').style.display = 'none';
          document.querySelector('.association-table .x-cards-y-categories').style.display = '';
        }
      }

      function exportResult() {
        if (navigator.clipboard) {
          let tableCSV = "";
          const xCardsHidden = document.querySelector('.association-table .x-cards-y-categories').style.display;
            if (xCardsHidden) {
              tableCSV = associationTable.getAttribute("data-content-ycsv");
          } else {
              tableCSV = associationTable.getAttribute("data-content-xcsv");
          }
          navigator.clipboard.writeText(tableCSV);
          const originalText = buttonExportResult.textContent;
          buttonExportResult.textContent = 'üìã Data copied to clipboard';
          clearTimeout(buttonExportResult._textTimeout);
          buttonExportResult._textTimeout = setTimeout(() => {
            buttonExportResult.textContent = originalText;
          }, 5000);
        }
        else {
          prompt('Your browser does not support clipboard. You may try copying the content from below.', serializedData);
        }
      }
      
      async function shareResult() {
        let sharedData = {};
        sharedData["Cards"] = loadedResults;
        sharedData["Categories"] = mergedCategories;
        sharedData["RenamedCategories"] = renamedCategories ? renamedCategories : {};
        const dataString = await saveToString(sharedData);
        const baseUrl = window.location.href.replace(regexRemoveBasenameFromUrl, '/');
        const url = baseUrl + 'analysis.html#' + dataString;
        if (navigator.share) {
          navigator.share({
            title: '',
            text: '',
            url: url,
          });
        }
        else if (navigator.clipboard) {
          navigator.clipboard.writeText(url);
          const originalText = buttonShareResult.textContent;
          buttonShareResult.textContent = 'üìã Link copied to clipboard';
          clearTimeout(buttonShareResult._textTimeout);
          buttonShareResult._textTimeout = setTimeout(() => {
            buttonShareResult.textContent = originalText;
          }, 5000);
        }
        else {
          window.location.href = url;
          alert('Your browser does not support sharing. Please copy from the address bar instead.');
        }
      }
      
      
      async function initialize() {
        if (window.location.hash) {
          data = await loadFromString(window.location.hash.split('#').pop());
          renamedCategories = data["RenamedCategories"] ? data["RenamedCategories"] : {};
          mergedCategories = data["Categories"];
          loadedResults = data["Cards"];
          calculateAndRender();
        }
      }

      function renderDendrogram(csvText, containerId = "dd-container", options = {}) {
        const cfg = Object.assign({
          width: Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0)*90/100,
          heightPerLeaf: 22,
          initialLinkage: 'average',
          initialK: 4,
          distanceFn:brayCurtisDistance,
          labelNum: 2,
        }, options);
        const DISTANCE_FUNCS = {
          'brayCurtisDistance': brayCurtisDistance,
          'jaccardDistance': jaccardDistance,
          'euclideanDistance': euclideanDistance,
          'manhattanDistance': manhattanDistance,
          'cosineDistance': cosineDistance
        };


        function inlineAndExportSVG(filename = 'dendrogram.svg') {
          const container = document.getElementById(containerId);
          if (!container) { alert('No container!'); return; }
          const svg = container.querySelector('svg');
          if (!svg) { alert('No SVG found to export'); return; }

          // Clone so we don't modify original displayed SVG
          const clone = svg.cloneNode(true);

          // Ensure namespace attrs
          clone.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
          clone.setAttribute('xmlns:xlink', 'http://www.w3.org/1999/xlink');

          // Helper: get computed style and return CSS text for relevant properties
          function computedStyleToString(el) {
            const cs = window.getComputedStyle(el);
            // list of properties commonly needed for SVG visuals; extend if necessary
            const props = [
              'fill', 'fill-opacity', 'stroke', 'stroke-width', 'stroke-opacity',
              'opacity', 'font-size', 'font-family', 'font-weight', 'text-anchor',
              'visibility', 'display'
            ];
            const parts = [];
            for (const p of props) {
              const v = cs.getPropertyValue(p);
              if (v && v !== '' && v !== 'none' && v !== 'rgba(0, 0, 0, 0)' && v !== 'normal') {
                parts.push(`${p}: ${v};`);
              }
            }
            return parts.join(' ');
          }

          // Walk DOM tree of clone and inline styles based on the original's computed style
          const origEls = svg.querySelectorAll('*');
          const cloneEls = clone.querySelectorAll('*');
          // include root element too
          const allOrig = [svg].concat(Array.from(origEls));
          const allClone = [clone].concat(Array.from(cloneEls));

          for (let i = 0; i < allOrig.length; i++) {
            const o = allOrig[i];
            const c = allClone[i];
            if (!o || !c) continue;

            const styleText = computedStyleToString(o);
            // Merge with existing inline style on clone (original attributes preserved)
            const existing = c.getAttribute('style') || '';
            c.setAttribute('style', (existing + ' ' + styleText).trim());

            // Some SVG viewers don't accept 'class' hooks; removing class helps portability
            c.removeAttribute('class');

            const attrsToCopy = ['width','height','viewBox','x','y','cx','cy','r','d','transform','x1','x2','y1','y2'];
            attrsToCopy.forEach(a => {
              if (!c.hasAttribute(a) && o.hasAttribute(a)) {
                c.setAttribute(a, o.getAttribute(a));
              }
            });
          }

          // Optionally inline <style> elements (copy them into the clone)
          const styleEls = Array.from(document.querySelectorAll('style'));
          if (styleEls.length) {
            const styleText = styleEls.map(s => s.textContent).join('\n');
            if (styleText.trim()) {
              const styleNode = document.createElementNS('http://www.w3.org/2000/svg', 'style');
              styleNode.textContent = styleText;
              // prepend so rules apply
              clone.insertBefore(styleNode, clone.firstChild);
            }
          }

          // Serialize
          const serializer = new XMLSerializer();
          let source = serializer.serializeToString(clone);
          if (!source.match(/^<\?xml/)) source = '<?xml version="1.0" standalone="no"?>\n' + source;

          const blob = new Blob([source], { type: 'image/svg+xml;charset=utf-8' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = filename;
          document.body.appendChild(a);
          a.click();
          a.remove();
          setTimeout(() => URL.revokeObjectURL(url), 1000);
        }


        // --- CSV parse ---
        function parseCSV(text){
          const lines = text.trim().split(/\r?\n/).map(l=>l.trim()).filter(Boolean);
          const header = lines.shift().split(',').map(h=>h.trim());
          const rows = lines.map(line => {
            const cols = line.split(',').map(c=>c.trim());
            const obj = {};
            header.forEach((h,i)=> obj[h] = cols[i]);
            return obj;
          });
          return { header, rows };
        }

        const parsed = parseCSV(csvText);
        const featureNames = parsed.header.slice(1);
        const items = parsed.rows.map((r, idx) => {
          const name = r[parsed.header[0]];
          const vec = featureNames.map(f => {
            const v = parseFloat(r[f]);
            return Number.isFinite(v) ? v : 0;
          });
          return { name, vec, origIndex: idx };
        });


        // --- Jaccard Distance  ---
        function jaccardDistance(a,b){
          let inter=0, uni=0;
          for(let i=0;i<a.length;i++){
            if(a[i]===1 || b[i]===1) uni++;
            if(a[i]===1 && b[i]===1) inter++;
          }
          return uni===0 ? 1 : 1 - (inter/uni);
        }
        // --- Bray-Curtis Distance ---
        function brayCurtisDistance(a, b) {
          let sumAbsDiff = 0;
          let sumAbs = 0;

          for (let i = 0; i < a.length; i++) {
            sumAbsDiff += Math.abs(a[i] - b[i]);
            sumAbs += a[i] + b[i];
          }

          return sumAbs === 0 ? 0 : sumAbsDiff / sumAbs;
        }
        // --- Euclidienne Distance ---
        function euclideanDistance(a, b) {
          let sum = 0;
          for (let i = 0; i < a.length; i++) {
            sum += Math.pow(a[i] - b[i], 2);
          }
          return Math.sqrt(sum);
        }
        // ---Manhattan Distance ---
        function manhattanDistance(a, b) {
          let sum = 0;
          for (let i = 0; i < a.length; i++) {
            sum += Math.abs(a[i] - b[i]);
          }
          return sum;
        }
        // --- Cosine Distance ---
        function cosineDistance(a, b) {
          let dotProduct = 0;
          let normA = 0;
          let normB = 0;

          for (let i = 0; i < a.length; i++) {
            dotProduct += a[i] * b[i];
            normA += Math.pow(a[i], 2);
            normB += Math.pow(b[i], 2);
          }

          const denominator = Math.sqrt(normA) * Math.sqrt(normB);
          return denominator === 0 ? 1 : 1 - (dotProduct / denominator);
        }



        // --- Agglomerative clustering ---
        function agglomerative(items, distanceFn, linkage='single'){

          const clusters = items.map((it, idx) => ({
            id: 'n'+idx, members: [idx], size:1, children: null, height: 0, name: it.name, index: idx
          }));
          const n0 = clusters.length;
          let dist = Array.from({length:n0},()=>Array(n0).fill(Infinity));

          // computing distances
          for(let i=0;i<n0;i++){
            for(let j=i+1;j<n0;j++){
              dist[i][j] = dist[j][i] = distanceFn(items[i].vec, items[j].vec);
            }
          }

          const active = new Set(Array.from({length:n0},(_,i)=>i));
          let currentIndex = n0;
          function findMinPair(){
            let mi=Infinity, a=-1,b=-1;
            for(const i of active){
              for(const j of active){
                if(i>=j) continue;
                if(dist[i][j] < mi){
                  mi = dist[i][j]; a=i; b=j;
                }
              }
            }
            return (a===-1) ? null : {a,b,d:mi};
          }
          while(active.size > 1){
            const pair = findMinPair();
            if(!pair) break;
            const {a,b,d} = pair;
            const newCluster = {
              id: 'n'+currentIndex,
              members: clusters[a].members.concat(clusters[b].members),
              size: clusters[a].size + clusters[b].size,
              children: [clusters[a], clusters[b]],
              height: d,
              name: null,
              index: currentIndex
            };
            clusters.push(newCluster);



            for(let i=0;i<dist.length;i++) dist[i].push(Infinity);
            dist.push(Array(dist.length+1).fill(Infinity));
            for(const i of active){
              if(i===a || i===b) continue;
              let dnew;
              if(linkage === 'single'){
                dnew = Math.min(dist[i][a], dist[i][b]);
              } else if(linkage === 'complete'){
                dnew = Math.max(dist[i][a], dist[i][b]);
              } else {
                const da = dist[i][a];
                const db = dist[i][b];
                const sa = clusters[a].size;
                const sb = clusters[b].size;
                dnew = (da*sa + db*sb) / (sa + sb);
              }
              dist[i][currentIndex] = dist[currentIndex][i] = dnew;
            }
            active.delete(a);
            active.delete(b);
            active.add(currentIndex);
            currentIndex++;
          }
          const rootIndex = Array.from(active)[0];
          return clusters[rootIndex];
        }

        // --- Layout computation ---
        function layoutTree(root){
          const leaves = [];
          (function collect(node){
            if(!node.children) { leaves.push(node); return; }
            collect(node.children[0]);
            collect(node.children[1]);
          })(root);
          const leafY = new Map();
          leaves.forEach((l,i)=> leafY.set(l.id, i));
          (function assign(node){
            if(!node.children){
              node.x = 0;
              node.y = leafY.get(node.id);
              return node;
            }
            const left = assign(node.children[0]);
            const right = assign(node.children[1]);
            node.x = node.height;
            node.y = (left.y + right.y)/2;
            return node;
          })(root);
          let maxH = 0;
          (function traverse(n){ if(n.height>maxH) maxH=n.height; if(n.children){ traverse(n.children[0]); traverse(n.children[1]); } })(root);
          if(maxH===0) maxH = 1;
          return { root, leaves, maxH };
        }

        function collectMerges(node, merges = []){
          if(!node.children) return merges;
          merges.push({ node, height: node.height });
          collectMerges(node.children[0], merges);
          collectMerges(node.children[1], merges);
          return merges;
        }

        function cutTree(root, k){
          const merges = collectMerges(root).sort((a,b)=>b.height - a.height);
          if(k<=1) return [root];
          const leaves = [];
          (function collectLeaves(n){ if(!n.children) leaves.push(n); else { collectLeaves(n.children[0]); collectLeaves(n.children[1]); } })(root);
          if(k >= leaves.length) return leaves;
          let clusters = [root];
          let i = 0;
          while(clusters.length < k && i < merges.length){
            const target = merges[i].node;
            const idx = clusters.findIndex(c => c === target);
            if(idx !== -1 && target.children){
              clusters.splice(idx, 1, target.children[0], target.children[1]);
            }
            i++;
          }
          let j = 0;
          while(clusters.length < k && j < clusters.length){
            if(clusters[j].children){
              const t = clusters[j];
              clusters.splice(j,1,t.children[0],t.children[1]);
            }
            j++;
          }
          return clusters.slice(0,k);
        }

        function assignClusterIds(root, clusters){
          const assign = {};
          clusters.forEach((c, ci)=>{
            (function mark(n){
              if(!n.children){
                assign[n.id] = ci;
                return;
              }
              mark(n.children[0]);
              mark(n.children[1]);
            })(c);
          });
          return assign;
        }

        function getColor(i){
          const palette = [
            '#1f77b4','#ff7f0e','#2ca02c','#d62728','#9467bd','#8c564b','#e377c2',
            '#7f7f7f','#bcbd22','#17becf','#a6cee3','#b2df8a','#fb9a99','#fdbf6f','#cab2d6'
          ];
          return palette[i % palette.length];
        }

        function computeClusterLabel(clusterNode, maxAttrs = 2) {
          const counts = new Array(featureNames.length).fill(0);

          (function collect(n) {
            if (!n.children) {
              n.members.forEach(mi => {
                const vec = items[mi].vec;
                for (let fi = 0; fi < vec.length; fi++) {
                  if (Number.isFinite(vec[fi]) && vec[fi] > 0) counts[fi] += Math.max(0, vec[fi]);
                }
              });
              return;
            }
            collect(n.children[0]);
            collect(n.children[1]);
          })(clusterNode);

          const arr = featureNames.map((f, fi) => [f, counts[fi]])
                                .filter(([f, c]) => c > 0)
                                .sort((a, b) => b[1] - a[1]);

          if (arr.length === 0) return '‚Äî';
          const top = arr.slice(0, maxAttrs).map(a => a[0]);
          return top.join(', ');
        }


        // draw function (uses clusterMap for badges)
        function drawDendrogram(containerId, layout, items, clusterMap = {}, opts = {}){
          const w = opts.width || cfg.width;
          const h = opts.height || Math.max(420, layout.leaves.length * cfg.heightPerLeaf);
          const margin = {top:40,right:20,bottom:20,left:220};
          const innerW = w - margin.left - margin.right;
          const innerH = h - margin.top - margin.bottom;

          function xScale(height){ return margin.left + (height / layout.maxH) * innerW; }
          function yScale(yIndex){ return margin.top + (yIndex / (layout.leaves.length-1 || 1)) * innerH; }

          const container = document.getElementById(containerId);
          container.innerHTML = '';
          const svgNS = "http://www.w3.org/2000/svg";
          const svg = document.createElementNS(svgNS,'svg');
          svg.setAttribute('width', w);
          svg.setAttribute('height', h);
          container.appendChild(svg);

          function drawLinks(node){
            if(!node.children) return;
            const left = node.children[0];
            const right = node.children[1];
            const x = xScale(node.x);
            const xl = xScale(left.x);
            const xr = xScale(right.x);
            const y = yScale(node.y);
            const yl = yScale(left.y);
            const yr = yScale(right.y);

            const hlineL = document.createElementNS(svgNS, 'path');
            hlineL.setAttribute('d', `M ${xl} ${yl} H ${x}`);
            hlineL.setAttribute('class','link');
            svg.appendChild(hlineL);

            const hlineR = document.createElementNS(svgNS, 'path');
            hlineR.setAttribute('d', `M ${xr} ${yr} H ${x}`);
            hlineR.setAttribute('class','link');
            svg.appendChild(hlineR);

            const vline = document.createElementNS(svgNS, 'path');
            vline.setAttribute('d', `M ${x} ${yl} V ${yr}`);
            vline.setAttribute('class','link');
            svg.appendChild(vline);

            drawLinks(left);
            drawLinks(right);
          }
          drawLinks(layout.root);

          layout.leaves.forEach(leaf => {
          const y = yScale(leaf.y);
          const x = margin.left - 12;
          const g = document.createElementNS(svgNS,'g');
          g.setAttribute('class','node');
          const text = document.createElementNS(svgNS,'text');
          const cid = clusterMap[leaf.id];
          text.setAttribute('x', x);
          text.setAttribute('y', y + 4);
          text.setAttribute('text-anchor','end');
          text.textContent = leaf.name || items[leaf.members[0]].name;
          if(typeof cid !== 'undefined'){
            text.textContent = text.textContent + ` ‚Äî C${cid+1}`;
          }
          if(typeof cid !== 'undefined'){
            text.setAttribute('fill', getColor(cid));
          } else {
            text.setAttribute('fill','#000');
          }
          g.appendChild(text);
          svg.appendChild(g);
          });

          const ticks = 5;
          for(let i=0;i<=ticks;i++){
            const hx = margin.left + (i/ticks) * innerW;
            const line = document.createElementNS(svgNS,'line');
            line.setAttribute('x1', hx);
            line.setAttribute('x2', hx);
            line.setAttribute('y1', margin.top - 10);
            line.setAttribute('y2', margin.top - 2);
            line.setAttribute('stroke','#6666ff');
            line.setAttribute('stroke-width','1');
            svg.appendChild(line);

            const label = document.createElementNS(svgNS,'text');
            label.setAttribute('x', hx);
            label.setAttribute('y', margin.top - 14);
            label.setAttribute('text-anchor','middle');
            const val = Math.round((i/ticks)*layout.maxH*100)/100;
            label.textContent = val;
            svg.appendChild(label);
          }
          

          // --- DRAW THRESHOLD LINE IF PROVIDED ---
          if(typeof opts.thresholdX !== 'undefined'){
            const tx = opts.thresholdX;
            const thrLine = document.createElementNS(svgNS,'line');
            thrLine.setAttribute('x1', tx);
            thrLine.setAttribute('x2', tx);
            thrLine.setAttribute('y1', margin.top - 8);
            thrLine.setAttribute('y2', h - margin.bottom + 6);
            thrLine.setAttribute('stroke', '#d62728');
            thrLine.setAttribute('stroke-width', '2');
            thrLine.setAttribute('stroke-dasharray', '6,4');
            thrLine.setAttribute('opacity', '0.9');
            svg.appendChild(thrLine);

            if(typeof opts.thresholdVal !== 'undefined'){
              const tlabel = document.createElementNS(svgNS,'text');
              tlabel.setAttribute('x', tx + 6);
              tlabel.setAttribute('y', margin.top + 12);
              tlabel.setAttribute('fill','#d62728');
              tlabel.textContent = `Threshold: ${Math.round(opts.thresholdVal*100)/100}`;
              svg.appendChild(tlabel);
            }
          }
        }

        const kRange = document.getElementById('kRange');
        const kValue = document.getElementById('kValue');
        const linkageSelect = document.getElementById('linkageSelect');

        function updateKMax(){
          const tree = agglomerative(items, cfg.distanceFn, linkageSelect.value);
          const layout = layoutTree(tree);
          const maxK = layout.leaves.length;
          kRange.max = maxK;
          if(Number(kRange.value) > maxK) kRange.value = maxK;
          kValue.textContent = kRange.value;
        }

        function render(linkage, k){
          const tree = agglomerative(items, cfg.distanceFn, linkage);
          const layout = layoutTree(tree);
          const clusterRoots = cutTree(layout.root, k);
          const clusterMap = assignClusterIds(layout.root, clusterRoots);

          // threshold
          const merges = collectMerges(layout.root).map(m=>m.height).sort((a,b)=>b-a);
          let thresholdVal = 0;
          if(k <= 1){
            thresholdVal = layout.maxH;
          } else if(k >= layout.leaves.length){
            thresholdVal = 0;
          } else {
            const idx = Math.min(merges.length-1, k-2);
            thresholdVal = merges[idx] || 0;
          }

          const w = cfg.width;
          const margin = {top:40,right:20,bottom:20,left:220};
          const innerW = w - margin.left - margin.right;
          const tx = margin.left + (thresholdVal / layout.maxH) * innerW;
          
          
          // legend
          const legend = document.getElementById('legend');
          legend.innerHTML = '';
          for(let i=0;i<clusterRoots.length;i++){
            const sw = document.createElement('span');
            sw.className = 'item';
            const cb = document.createElement('span');
            cb.className = 'colorbox';
            cb.style.background = getColor(i);
            sw.appendChild(cb);

            const cnt = (function countLeaves(n){ if(!n.children) return 1; return countLeaves(n.children[0]) + countLeaves(n.children[1]); })(clusterRoots[i]);
            const autoLabel = computeClusterLabel(clusterRoots[i], cfg.labelNum);

            const labelText = document.createElement('span');
            labelText.textContent = `C${i+1} (${cnt}) ‚Äî ${autoLabel}`;
            labelText.style.cursor = 'pointer';
            labelText.title = 'Click to edit the cat. label';
            sw.appendChild(labelText);

            labelText.addEventListener('click', function onClick(){
              const input = document.createElement('input');
              input.type = 'text';
              input.value = (labelText.textContent.split('‚Äî').slice(1).join('‚Äî') || autoLabel).trim();
              input.className = 'editable-input';
              input.style.minWidth = '100px';
              function commit(){
                const newVal = input.value.trim() || autoLabel;
                labelText.textContent = `C${i+1} (${cnt}) ‚Äî ${newVal}`;
                labelText.addEventListener('click', onClick, { once: true });
                input.replaceWith(labelText);
              }
              function cancel(){
                labelText.addEventListener('click', onClick, { once: true });
                input.replaceWith(labelText);
              }
              sw.replaceChild(input, labelText);
              input.focus();
              input.select();
              input.addEventListener('blur', commit, { once: true });
              input.addEventListener('keydown', (ev)=>{
                if(ev.key === 'Enter') input.blur();
                if(ev.key === 'Escape') { cancel(); }
              });
            }, { once: true });

            legend.appendChild(sw);
          }

          drawDendrogram(containerId, layout, items, clusterMap, {
            width: cfg.width,
            height: Math.max(420, layout.leaves.length*cfg.heightPerLeaf),
            thresholdX: tx,
            thresholdVal: thresholdVal
          });
        }

        kRange.addEventListener('input', ()=>{
          kValue.textContent = kRange.value;
          render(linkageSelect.value, Number(kRange.value));
        });

        document.getElementById('redraw').addEventListener('click', ()=>{
          updateKMax();
          render(linkageSelect.value, Number(kRange.value));
        });

        linkageSelect.addEventListener('change', ()=>{
          updateKMax();
          render(linkageSelect.value, Number(kRange.value));
        });
        
        labelNum.addEventListener('change', ()=>{
          cfg.labelNum = labelNum.value;
          updateKMax();
          render(linkageSelect.value, Number(kRange.value));
        });

        distSelect.addEventListener('change', ()=>{
          const key = distSelect.value;
          if (DISTANCE_FUNCS.hasOwnProperty(key)) {
            cfg.distanceFn = DISTANCE_FUNCS[key];
          } else {
            console.warn('Unknown distance algorithm:', key);
          }
          updateKMax();
          render(linkageSelect.value, Number(kRange.value));
        });

        document.getElementById('exportSvg').addEventListener('click', () => inlineAndExportSVG('dendrogram.svg'));

        // initial render
        linkageSelect.value = cfg.initialLinkage || linkageSelect.value;
        distSelect.value = cfg.distanceFn.name || distSelect.value;
        labelNum.value = cfg.labelNum || labelNum.value;
        kRange.value = Math.min(Number(kRange.max), cfg.initialK || Number(kRange.value));
        updateKMax();
        render(linkageSelect.value, Number(kRange.value));

      }

    </script>
  </body>
</html>
